use std::collections::HashMap;
use super::evaluator::{Evaluator, EvalResult};

/// This scope enum allows `Evaluator` struct to use two different kinds of scopes:
/// `OpenScope` - Holds a map for defined variables and their values and a reference to the parent
/// scope. This is the scope variant that should always be used.
/// `ClosedScope` - A completely owned scope variant. This scope variant should only be used in
/// closures.
#[derive(PartialEq)]
#[derive(Debug)]
pub enum Scope<'parent, 'ast: 'parent> {
    Open(&'parent OpenScope<'parent, 'ast>),
    Closed(&'parent ClosedScope),
}
impl<'parent, 'ast: 'parent> Scope<'parent, 'ast> {
    /// Returns an owned `ClosedScope`.
    ///
    /// If this is of variant `Scope::Closed` then the referenced scope will be cloned and
    /// returned.
    ///
    /// If this is of variant `Scope::Open` then `to_closed()` will be called on the referenced
    /// scope and the value will be returned.
    pub fn to_closed(&self) -> ClosedScope {
        match self {
            &Scope::Open(ref scope) => scope.to_closed(),
            &Scope::Closed(ref scope) => Clone::clone(scope),
        }
    }

    /// Calls `get_value(id_name)` will be called on the referenced scope and the result will be
    /// returned.
    pub fn get_value(&self, id_name: &str) -> Option<EvalResult> {
        match self {
            &Scope::Open(ref scope) => scope.get_value(id_name),
            &Scope::Closed(ref scope) => scope.get_value(id_name),
        }
    }
}
impl<'parent, 'ast: 'parent> Clone for Scope<'parent, 'ast> {
    fn clone(&self) -> Scope<'parent, 'ast> {
        match self {
            &Scope::Open(ref s) => Scope::Open(s),
            &Scope::Closed(ref s) => Scope::Closed(s),
        }
    }
}

/// OpenScope holds a map for variable definitions and their values. 
/// It also holds a reference to it's parent scope.
/// This scope type is more efficient than `ClosedScope` and should be used as much as possible.
#[derive(PartialEq)]
#[derive(Debug)]
pub struct OpenScope<'parent, 'ast: 'parent> {
    /// The parent scope.
    pub parent: Option<Scope<'parent, 'ast>>,
    /// Map of variable definitions and their values.
    pub map: HashMap<&'ast str, Evaluator<'parent, 'ast>>,
}
impl<'parent, 'ast: 'parent> OpenScope<'parent, 'ast> {
    /// Creates a new OpenScope with no parent scope and no variable definitions in the map.
    pub fn new() -> Self {
        OpenScope{parent: None, map: HashMap::new()}
    }

    /// Recursively looks up a variable definition and evaluates it.
    ///
    /// # Attributes
    /// `id_name` - the name of the variable to look up.
    ///
    /// If there is no variable with the name `id_name` in the map or in the map of any forefather
    /// scopes then `None` is returned.
    pub fn get_value(&self, id_name: &str) -> Option<EvalResult> {
        if let Some(eval) = self.map.get(id_name) {
            Some(eval.eval())
        } else if let Some(ref parent) = self.parent {
            parent.get_value(id_name)
        } else {
            None
        }
    }

    /// Recursively copies all of its variables (and parent variables) into 
    /// one owned `ClosedScope`.
    /// This operation is very ineficient.
    pub fn to_closed(&self) -> ClosedScope {
        let mut closed_map = HashMap::new();
        for (key, value) in self.map.iter() {
            closed_map.insert(key.to_string(), value.eval());
        }

        let mut closed_scope = ClosedScope{map: closed_map};

        if let Some(ref parent) = self.parent {
            closed_scope.merge(&parent.to_closed());
        }

        closed_scope
    }
}

/// A completely owned and self-contained scope version of OpenScope.
/// Can be generated by calling `to_closed()` on `OpenScope`.
/// This is scope type should only be used for closures.
#[derive(PartialEq)]
#[derive(Debug)]
#[derive(Clone)]
pub struct ClosedScope {
    pub map: HashMap<String, EvalResult>,
}
impl ClosedScope {
    /// Looks up variable with name `id_name`, evaluates it and returns the result.
    /// If there is no variable with the name `id_name` then `None` is returned.
    pub fn get_value(&self, id_name: &str) -> Option<EvalResult> {
        if let Some(eval) = self.map.get(id_name) {
            Some(Clone::clone(eval))
        } else {
            None
        }
    }

    /// Merges the map of `other` into it's own map.
    /// Only variables with names that don't already exist in the current map are copied from
    /// `other` - this guarantees that no variables this scope are overwritten.
    pub fn merge(&mut self, other: &ClosedScope) {
        for (key, value) in other.map.iter() {
            if self.map.get(key) == None {
                self.map.insert(key.to_string(), Clone::clone(value));
            }
        }
    }
}
